<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  

  <title>
    Returning from Exceptions &middot; Writing an OS in Rust
  </title>

  <link rel="canonical" href="http://os.phil-opp.com/returning-from-exceptions.html">

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/syntax.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/images/favicon.ico">

  

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/2.0.0/anchor.min.js"></script>
  <script src="js/toc.min.js"></script>
  <script src="js/main.js"></script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-65296949-1', 'auto');
  ga('send', 'pageview');

</script>


  
  <script type="text/javascript">
    if (window.location.hostname == "phil-opp.github.io") {
      window.location.href = "http://os.phil-opp.com/";
    }
  </script>
</head>

<body>
<div class="container content">

<header class="masthead">
  <h3 class="masthead-title">
    <a href="/" title="Home">Writing an OS in Rust</a>
    <span class="navigation">
      <small><a href="/atom.xml"><img src="/images/feed-icon.png" alt="RSS"></a></small>
    </span>
    <small>Philipp&nbsp;Oppermann's&nbsp;blog</small>
  </h3>
</header>

<main>


<article class="post">
  <h1 class="post-title">Returning from Exceptions</h1>
  <time datetime="2016-09-21" class="post-date">
    Sep 21, 2016
    
      (updated on Nov 1, 2016)
    
  </time>

  

<p>In this post, we learn how to return from exceptions correctly. In the course of this, we will explore the <code>iretq</code> instruction, the C calling convention, multimedia registers, and the red zone.</p>

<aside id="toc"></aside>

<p>As always, the complete source code is on <a href="https://github.com/phil-opp/blog_os/tree/returning_from_exceptions">Github</a>. Please file <a href="https://github.com/phil-opp/blog_os/issues">issues</a> for any problems, questions, or improvement suggestions. There is also a <a href="https://gitter.im/phil-opp/blog_os">gitter chat</a> and a <a href="#disqus_thread">comment section</a> at the end of this page.</p>

<h2 id="introduction">Introduction</h2>

<p>Most exceptions are fatal and can&rsquo;t be resolved. For example, we can&rsquo;t return from a divide-by-zero exception in a reasonable way. However, there are some exceptions that we can resolve:</p>

<p>Imagine a system that uses <a href="https://en.wikipedia.org/wiki/Memory-mapped_file">memory mapped files</a>: We map a file into the virtual address space without loading it into memory. Whenever we access a part of the file for the first time, a page fault occurs. However, this page fault is not fatal. We can resolve it by loading the corresponding page from disk into memory and setting the <code>present</code> flag in the page table. Then we can return from the page fault handler and restart the failed instruction, which now successfully accesses the file data.</p>

<p>Memory mapped files are completely out of scope for us right now (we have neither a file concept nor a hard disk driver). So we need an exception that we can resolve easily so that we can return from it in a reasonable way. Fortunately, there is an exception that needs no resolution at all: the breakpoint exception.</p>

<h2 id="the-breakpoint-exception">The Breakpoint Exception</h2>

<p>The breakpoint exception is the perfect exception to test our upcoming return-from-exception logic. Its only purpose is to temporary pause a program when the breakpoint instruction <code>int3</code> is executed.</p>

<p>The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the <code>int3</code> instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the <code>int3</code> instruction with the original instruction again and continues the program. For more details, see the <a href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints">How debuggers work</a> series.</p>

<p>For our use case, we don&rsquo;t need to overwrite any instructions (it wouldn&rsquo;t even be possible since we <a href="/remap-the-kernel.html#using-the-correct-flags">set the page table flags</a> to read-only). Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program.</p>

<h3 id="catching-breakpoints">Catching Breakpoints</h3>

<p>Let&rsquo;s start by defining a handler function for the breakpoint exception:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="k">break</span><span class="n">point_handler</span><span class="p">(</span><span class="n">stack_frame</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ExceptionStackFrame</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stack_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">stack_frame</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">EXCEPTION: BREAKPOINT at {:#x}</span><span class="se">\n</span><span class="s">{:#?}&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">stack_frame</span><span class="p">.</span><span class="n">instruction_pointer</span><span class="p">,</span><span class="w"> </span><span class="n">stack_frame</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>We print an error message and also output the instruction pointer and the rest of the stack frame. Note that this function does <em>not</em> return yet, since our <code>handler!</code> macro still requires a diverging function.</p>

<p>We need to register our new handler function in the interrupt descriptor table (IDT):</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">IDT</span><span class="o">:</span><span class="w"> </span><span class="n">idt</span><span class="o">::</span><span class="n">Idt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">idt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idt</span><span class="o">::</span><span class="n">Idt</span><span class="o">::</span><span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">idt</span><span class="p">.</span><span class="n">set_handler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="o">!</span><span class="p">(</span><span class="n">divide_by_zero_handler</span><span class="p">));</span><span class="w"></span>
<span class="hll"><span class="w">        </span><span class="n">idt</span><span class="p">.</span><span class="n">set_handler</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="o">!</span><span class="p">(</span><span class="k">break</span><span class="n">point_handler</span><span class="p">));</span><span class="w"> </span><span class="c1">// new</span>
</span><span class="w">        </span><span class="n">idt</span><span class="p">.</span><span class="n">set_handler</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="o">!</span><span class="p">(</span><span class="n">invalid_opcode_handler</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">idt</span><span class="p">.</span><span class="n">set_handler</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="n">handler_with_error_code</span><span class="o">!</span><span class="p">(</span><span class="n">page_fault_handler</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="n">idt</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>We set the IDT entry with number 3 since it&rsquo;s the vector number of the breakpoint exception.</p>

<h4 id="testing-it">Testing it</h4>

<p>In order to test it, we insert an <code>int3</code> instruction in our <code>rust_main</code>:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/lib.rs</span>
<span class="p">...</span><span class="w"></span>
<span class="hll"><span class="cp">#[macro_use]</span><span class="w"> </span><span class="c1">// needed for the `int!` macro</span>
</span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">x86</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>

<span class="cp">#[no_mangle]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">rust_main</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">interrupts</span><span class="o">::</span><span class="n">init</span><span class="p">();</span><span class="w"></span>

<span class="hll"><span class="w">    </span><span class="c1">// trigger a breakpoint exception</span>
</span><span class="hll"><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">int</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;It did not crash!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>When we execute <code>make run</code>, we see the following:</p>

<p><img src="images/qemu-breakpoint-handler.png" alt="QEMU showing `EXCEPTION: BREAKPOINT at 0x110970` and a dump of the exception stack frame" /></p>

<p>It works! Now we “just” need to return from the breakpoint handler somehow so that we see the <code>It did not crash</code> message again.</p>

<h2 id="returning-from-exceptions">Returning from Exceptions</h2>

<p>So how do we return from exceptions? To make it easier, we look at a normal function return first:</p>

<p><img src="images/function-stack-frame.svg" alt="function stack frame" /></p>

<p>When calling a function, the <code>call</code> instruction pushes the return address on the stack. When the called function is finished, it can return to the parent function through the <code>ret</code> instruction, which pops the return address from the stack and then jumps to it.</p>

<p>The exception stack frame, in contrast, looks a bit different:</p>

<p><img src="images/exception-stack-frame.svg" alt="exception stack frame" /></p>

<p>Instead of pushing a return address, the CPU pushes the stack and instruction pointers (with their segment descriptors), the RFLAGS register, and an optional error code. It also aligns the stack pointer to a 16 byte boundary before pushing values.</p>

<p>So we can&rsquo;t use a normal <code>ret</code> instruction, since it expects a different stack frame layout. Instead, there is a special instruction for returning from exceptions: <code>iretq</code>.</p>

<h3 id="the-iretq-instruction">The <code>iretq</code> Instruction</h3>

<p>The <code>iretq</code> instruction is the one and only way to return from exceptions and is specifically designed for this purpose. The AMD64 manual (<a href="https://support.amd.com/TechDocs/24594.pdf">PDF</a>) even demands that <code>iretq</code> “<em>must</em> be used to terminate the exception or interrupt handler associated with the exception”.</p>

<p>IRETQ restores <code>rip</code>, <code>cs</code>, <code>rflags</code>, <code>rsp</code>, and <code>cs</code> from the values saved on the stack and thus continues the interrupted program. The instruction does not handle the optional error code, so it must be popped from the stack before.</p>

<p>We see that <code>iretq</code> treats the stored instruction pointer as return address. For most exceptions, the stored <code>rip</code> points to the instruction that caused the fault. So by executing <code>iretq</code>, we restart the failing instruction. This makes sense because we should have resolved the exception when returning from it, so the instruction should no longer fail (e.g. the accessed part of the memory mapped file is now present in memory).</p>

<p>The situation is a bit different for the breakpoint exception, since it needs no resolution. Restarting the <code>int3</code> instruction wouldn&rsquo;t make sense, since it would cause a new breakpoint exception and we would enter an endless loop. For this reason the hardware designers decided that the stored <code>rip</code> should point to the next instruction after the <code>int3</code> instruction.</p>

<p>Let&rsquo;s check this for our breakpoint handler. Remember, the handler printed the following message (see the image above):</p>

<pre><code>EXCEPTION: BREAKPOINT at 0x110970
</code></pre>

<p>So let&rsquo;s disassemble the instruction at <code>0x110970</code> and its predecessor:</p>

<div class="highlight"><pre><code class="language-shell" data-lang="shell"><span></span>&gt; objdump -d build/kernel-x86_64.bin <span class="p">|</span> grep -B1 <span class="s2">&quot;110970:&quot;</span>
11096f:	cc                   	int3
<span class="hll">110970:	<span class="m">48</span> c7 <span class="m">01</span> 2a <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 	movq   <span class="nv">$0</span>x2a,<span class="o">(</span>%rcx<span class="o">)</span>
</span></code></pre></div>


<p>We see that <code>0x110970</code> indeed points to the next instruction after <code>int3</code>. So we can simply jump to the stored instruction pointer when we want to return from the breakpoint exception.</p>

<h3 id="implementation">Implementation</h3>

<p>Let&rsquo;s update our <code>handler!</code> macro to support non-diverging exception handlers:</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$name</span><span class="o">:</span><span class="w"> </span><span class="n">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[naked]</span><span class="w"></span>
<span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">wrapper</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;mov rdi, rsp</span>
<span class="s">                      sub rsp, 8 // align the stack pointer</span>
<span class="s">                      call $0&quot;</span><span class="w"></span>
<span class="w">                      </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="cp">$name</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="w"></span>
<span class="hll"><span class="w">                          </span><span class="o">&amp;</span><span class="n">ExceptionStackFrame</span><span class="p">))</span><span class="w"> </span><span class="c1">// no longer diverging</span>
</span><span class="w">                      </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;rdi&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">                </span><span class="c1">// new</span>
<span class="hll"><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;add rsp, 8 // undo stack pointer alignment</span>
</span><span class="hll"><span class="s">                      iretq&quot;</span><span class="w"></span>
</span><span class="hll"><span class="w">                      </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
</span><span class="w">                </span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">intrinsics</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">wrapper</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<!--end*--></p>

<p>When an exception handler returns from the <code>call</code> instruction, we use the <code>iretq</code> instruction to continue the interrupted program. Note that we need to undo the stack pointer alignment before, so that <code>rsp</code> points to the end of the exception stack frame again.</p>

<p>We&rsquo;ve changed the handler function type, so we need to adjust our existing exception handlers:</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"><span></span>// in src/interrupts/mod.rs

extern &quot;C&quot; fn divide_by_zero_handler(
<span class="gd">-   stack_frame: &amp;ExceptionStackFrame) -&gt; ! {...}</span>
<span class="gi">+   stack_frame: &amp;ExceptionStackFrame) {...}</span>

extern &quot;C&quot; fn invalid_opcode_handler(
<span class="gd">-   stack_frame: &amp;ExceptionStackFrame) -&gt; ! {...}</span>
<span class="gi">+   stack_frame: &amp;ExceptionStackFrame) {...}</span>

extern &quot;C&quot; fn breakpoint_handler(
<span class="gd">-   stack_frame: &amp;ExceptionStackFrame) -&gt; ! {</span>
<span class="gi">+   stack_frame: &amp;ExceptionStackFrame) {</span>
    println!(...);
<span class="gd">-   loop {}</span>
}
</code></pre></div>

<p>Note that we also removed the <code>loop {}</code> at the end of our <code>breakpoint_handler</code> so that it no longer diverges. The <code>divide_by_zero_handler</code> and the <code>invalid_opcode_handler</code> still diverge (albeit the new function type would allow a return).</p>

<h3 id="testing">Testing</h3>

<p>Let&rsquo;s try our new <code>iretq</code> logic:</p>

<p><img src="images/qemu-breakpoint-return-page-fault.png" alt="QEMU output with `EXCEPTION BREAKPOINT` and `EXCEPTION PAGE FAULT` but no `It did not crash`" /></p>

<p>Instead of the expected <em>“It did not crash”</em> message after the breakpoint exception, we get a page fault. The strange thing is that our kernel tried to access address <code>0x1</code>, which should never happen. So it seems like we messed up something important.</p>

<h3 id="debugging">Debugging</h3>

<p>Let&rsquo;s debug it using GDB. For that we execute <code>make debug</code> in one terminal (which starts QEMU with the <code>-s -S</code> flags) and then <code>make gdb</code> (which starts and connects GDB) in a second terminal. For more information about GDB debugging, check out our <a href="/set-up-gdb.html">Set Up GDB</a> guide.</p>

<p>First we want to check if our <code>iretq</code> was successful. Therefore we set a breakpoint on the <code>println!(&quot;It did not crash line!&quot;)</code> statement in <code>src/lib.rs</code>. Let&rsquo;s assume that it&rsquo;s on line 61:</p>

<pre><code>(gdb) break blog_os/src/lib.rs:61
Breakpoint 1 at 0x110a95: file /home/.../blog_os/src/lib.rs, line 61.
</code></pre>

<p>This line is after the <code>int3</code> instruction, so we know that the <code>iretq</code> succeeded when the breakpoint is hit. To test this, we continue the execution:</p>

<pre><code>(gdb) continue
Continuing.

Breakpoint 1, blog_os::rust_main (multiboot_information_address=1539136)
    at /home/.../blog_os/src/lib.rs:61
61	    println!(&quot;It did not crash!&quot;);

</code></pre>

<p>It worked! So our kernel successfully returned from the <code>int3</code> instruction, which means that the <code>iretq</code> itself works.</p>

<p>However, when we <code>continue</code> the execution again, we get the page fault. So the exception occurs somewhere in the <code>println</code> logic. This means that it occurs in code generated by the compiler (and not e.g. in inline assembly). But the compiler should never access <code>0x1</code>, so how is this happening?</p>

<p>The answer is that we&rsquo;ve used the wrong <em>calling convention</em> for our exception handlers. Thus, we violate some compiler invariants so that the code that works fine without intermediate exceptions starts to violate memory safety when it&rsquo;s executed after a breakpoint exception.</p>

<h2 id="calling-conventions">Calling Conventions</h2>

<p>Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the (handler) function and executes the function. Afterwards, if the function is not diverging, the CPU jumps to the return address and continues the execution of the parent function.</p>

<p>However, there is a major difference between exceptions and function calls: A function call is invoked voluntary by a compiler inserted <code>call</code> instruction, while an exception might occur at <em>any</em> instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.</p>

<p><a href="https://en.wikipedia.org/wiki/Calling_convention">Calling conventions</a> specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the <a href="http://refspecs.linuxbase.org/elf/x86-64-abi-0.99.pdf">System V ABI</a>):</p>

<ul>
<li>the first six integer arguments are passed in registers <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code></li>
<li>additional arguments are passed on the stack</li>
<li>results are returned in <code>rax</code> and <code>rdx</code></li>
</ul>

<p>Note that Rust does not follow the C ABI (in fact, <a href="https://github.com/rust-lang/rfcs/issues/600">there isn&rsquo;t even a Rust ABI yet</a>). So these rules apply only to functions declared as <code>extern &quot;C&quot; fn</code>.</p>

<h3 id="preserved-and-scratch-registers">Preserved and Scratch Registers</h3>

<p>The calling convention divides the registers in two parts: <em>preserved</em> and <em>scratch</em> registers.</p>

<p>The values of the preserved register must remain unchanged across function calls. So a called function (the <em>“callee”</em>) is only allowed to overwrite these registers if it restores their original values before returning. Therefore these registers are called <em>“callee-saved”</em>. A common pattern is to save these registers to the stack at the function&rsquo;s beginning and restore them just before returning.</p>

<p>In contrast, a called function is allowed to overwrite scratch registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it (e.g. by pushing it to the stack before the function call). So the scratch registers are <em>caller-saved</em>.</p>

<p>On x86_64, the C calling convention specifies the following preserved and scratch registers:</p>

<table>
<thead>
<tr>
<th>preserved registers</th>
<th>scratch registers</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>rbp</code>, <code>rbx</code>, <code>rsp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code></td>
<td><code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code></td>
</tr>

<tr>
<td><em>callee-saved</em></td>
<td><em>caller-saved</em></td>
</tr>
</tbody>
</table>

<p>The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a <code>push rbp</code>, which backups <code>rbp</code> on the stack (because it&rsquo;s a callee-saved register).</p>

<h3 id="the-exception-calling-convention">The Exception Calling Convention</h3>

<p>In contrast to function calls, exceptions can occur on <em>any</em> instruction. In most cases we don&rsquo;t even know at compile time if the generated code will cause an exception. For example, the compiler can&rsquo;t know if an instruction causes a stack overflow or an other page fault.</p>

<p>Since we don&rsquo;t know when an exception occurs, we can&rsquo;t backup any registers before. This means that we can&rsquo;t use a calling convention that relies on caller-saved registers for our exception handlers. But we do so at the moment: Our exception handlers are declared as <code>extern &quot;C&quot; fn</code> and thus use the C calling convention.</p>

<p>So here is what happens:</p>

<ul>
<li><code>rust_main</code> is executing; it writes some memory address into <code>rax</code>.</li>
<li>The <code>int3</code> instruction causes a breakpoint exception.</li>
<li>Our <code>breakpoint_handler</code> prints to the screen and assumes that it can overwrite <code>rax</code> freely (since it&rsquo;s a scratch register). Somehow the value <code>0</code> ends up in <code>rax</code>.</li>
<li>We return from the breakpoint exception using <code>iretq</code>.</li>
<li><code>rust_main</code> continues and accesses the memory address in <code>rax</code>.</li>
<li>The CPU tries to access address <code>0x1</code>, which causes a page fault.</li>
</ul>

<p>So our exception handler erroneously assumes that the scratch registers were saved by the caller. But the caller (<code>rust_main</code>) couldn&rsquo;t save any registers since it didn&rsquo;t know that an exception occurs. So nobody saves <code>rax</code> and the other scratch registers, which leads to the page fault.</p>

<p>The problem is that we use a calling convention with caller-saved registers for our exception handlers. Instead, we need a calling convention means that preserves <em>all registers</em>. In other words, all registers must be callee-saved:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;all-registers-callee-saved&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">exception_handler</span><span class="p">()</span><span class="w"> </span><span class="p">{...}</span><span class="w"></span>
</code></pre></div>

<p>Unfortunately, Rust does not support such a calling convention. It was <a href="https://github.com/rust-lang/rfcs/pull/1275">proposed once</a>, but did not get accepted for various reasons. The primary reason was that such calling conventions can be simulated by writing a naked wrapper function.</p>

<p>(Remember: <a href="https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md">Naked functions</a> are functions without prologue and can contain only inline assembly. They were discussed in the <a href="/better-exception-messages.html#naked-functions">previous post</a>.)</p>

<h3 id="a-naked-wrapper-function">A naked wrapper function</h3>

<p>Such a naked wrapper function might look like this:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="cp">#[naked]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">calling_convention_wrapper</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;</span>
<span class="s">            push rax</span>
<span class="s">            push rcx</span>
<span class="s">            push rdx</span>
<span class="s">            push rsi</span>
<span class="s">            push rdi</span>
<span class="s">            push r8</span>
<span class="s">            push r9</span>
<span class="s">            push r10</span>
<span class="s">            push r11</span>
<span class="s">            // TODO: call exception handler with C calling convention</span>
<span class="s">            pop r11</span>
<span class="s">            pop r10</span>
<span class="s">            pop r9</span>
<span class="s">            pop r8</span>
<span class="s">            pop rdi</span>
<span class="s">            pop rsi</span>
<span class="s">            pop rdx</span>
<span class="s">            pop rcx</span>
<span class="s">            pop rax</span>
<span class="s">        &quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>This wrapper function saves all <em>scratch</em> registers to the stack before calling the exception handler and restores them afterwards. Note that we <code>pop</code> the registers in reverse order.</p>

<p>We don&rsquo;t need to backup <em>preserved</em> registers since they are callee-saved in the C calling convention. Thus, the compiler already takes care of preserving their values.</p>

<h3 id="fixing-our-handler-macro">Fixing our Handler Macro</h3>

<p>Let&rsquo;s update our handler macro to fix the calling convention problem. Therefore we need to backup and restore all scratch registers. For that we create two new macros:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">save_scratch_registers</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;push rax</span>
<span class="s">              push rcx</span>
<span class="s">              push rdx</span>
<span class="s">              push rsi</span>
<span class="s">              push rdi</span>
<span class="s">              push r8</span>
<span class="s">              push r9</span>
<span class="s">              push r10</span>
<span class="s">              push r11</span>
<span class="s">        &quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">restore_scratch_registers</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;pop r11</span>
<span class="s">              pop r10</span>
<span class="s">              pop r9</span>
<span class="s">              pop r8</span>
<span class="s">              pop rdi</span>
<span class="s">              pop rsi</span>
<span class="s">              pop rdx</span>
<span class="s">              pop rcx</span>
<span class="s">              pop rax</span>
<span class="s">            &quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>We need to declare these macros <em>above</em> our <code>handler</code> macro, since macros are only available after their declaration.</p>

<p>Now we can use these macros to fix our <code>handler!</code> macro:</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$name</span><span class="o">:</span><span class="w"> </span><span class="n">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[naked]</span><span class="w"></span>
<span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">wrapper</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="hll"><span class="w">                </span><span class="n">save_scratch_registers</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
</span><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;mov rdi, rsp</span>
<span class="hll"><span class="s">                      add rdi, 9*8 // calculate exception stack frame pointer</span>
</span><span class="hll"><span class="s">                      // sub rsp, 8 (stack is aligned already)</span>
</span><span class="s">                      call $0&quot;</span><span class="w"></span>
<span class="w">                      </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="cp">$name</span><span class="w"> </span><span class="k">as</span><span class="w"></span>
<span class="w">                             </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ExceptionStackFrame</span><span class="p">))</span><span class="w"></span>
<span class="w">                      </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;rdi&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>

<span class="hll"><span class="w">                </span><span class="n">restore_scratch_registers</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
</span><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;</span>
<span class="hll"><span class="s">                      // add rsp, 8 (undo stack alignment; not needed anymore)</span>
</span><span class="s">                      iretq&quot;</span><span class="w"></span>
<span class="w">                      </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">intrinsics</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">wrapper</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<!--end*--></p>

<p>It&rsquo;s important that we save the registers first, before we modify any of them. After the <code>call</code> instruction (but before <code>iretq</code>) we restore the registers again. Because we&rsquo;re now changing <code>rsp</code> (by pushing the register values) before we load it into <code>rdi</code>, we would get a wrong exception stack frame pointer. Therefore we need to adjust it by adding the number of bytes we push. We push 9 registers that are 8 bytes each, so <code>9 * 8</code> bytes in total.</p>

<p>Note that we no longer need to manually align the stack pointer, because we&rsquo;re pushing an uneven number of registers in <code>save_scratch_registers</code>. Thus the stack pointer already has the required 16-byte alignment.</p>

<h3 id="testing-it-again">Testing it again</h3>

<p>Let&rsquo;s test it again with our corrected <code>handler!</code> macro:</p>

<p><img src="images/qemu-breakpoint-return.png" alt="QEMU output with `EXCEPTION BREAKPOINT` and `It did not crash`" /></p>

<p>The page fault is gone and we see the <em>“It did not crash”</em> message again!</p>

<p>So the page fault occurred because our exception handler didn&rsquo;t preserve the scratch register <code>rax</code>. Our new <code>handler!</code> macro fixes this problem by saving all scratch registers (including <code>rax</code>) before calling exception handlers. Thus, <code>rax</code> still contains the valid memory address when <code>rust-main</code> continues execution.</p>

<h2 id="multimedia-registers">Multimedia Registers</h2>

<p>When we discussed calling conventions above, we assummed that a x86_64 CPU only has the following 16 registers: <code>rax</code>, <code>rbx</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>rsp</code>, <code>rbp</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code>.<code>r12</code>, <code>r13</code>, <code>r14</code>, and <code>r15</code>. These registers are called <em>general purpose registers</em> since each of them can be used for arithmetic and load/store instructions.</p>

<p>However, modern CPUs also have a set of <em>special purpose registers</em>, which can be used to improve performance in several use cases. On x86_64, the most important set of special purpose registers are the <em>multimedia registers</em>. These registers are larger than the general purpose registers and can be used to speed up audio/video processing or matrix calculations. For example, we could use them to add two 4-dimensional vectors <em>in a single CPU instruction</em>:</p>

<p><img src="http://mathurl.com/jz3nvev.png" alt="`(1,2,3,4) + (5,6,7,8) = (6,8,10,12)`" /></p>

<p>Such multimedia instructions are called <a href="https://en.wikipedia.org/wiki/SIMD">Single Instruction Multiple Data (SIMD)</a> instructions, because they simultaneously perform an operation (e.g. addition) on multiple data words. Good compilers are able to transform normal loops into such SIMD code automatically. This process is called <a href="https://en.wikipedia.org/wiki/Automatic_vectorization">auto-vectorization</a> and can lead to huge performance improvements.</p>

<p>However, auto-vectorization causes a problem for us: Most of the multimedia registers are caller-saved. According to our discussion of calling conventions above, this means that our exception handlers erroneously assume that they are allowed to overwrite them without preserving their values.</p>

<p>We don&rsquo;t use any multimedia registers explicitly, but the Rust compiler might auto-vectorize our code (including the exception handlers). Thus we could silently clobber the multimedia registers, which leads to the same problems as above:</p>

<p><img src="images/xmm-overwrite.svg" alt="example: program uses mm0, mm1, and mm2. Then the exception handler clobbers mm1." /></p>

<p>This example shows a program that is using the first three multimedia registers (<code>mm0</code> to <code>mm2</code>). At some point, an exception occurs and control is transfered to the exception handler. The exception handler uses <code>mm1</code> for its own data and thus overwrites the previous value. When the exception is resolved, the CPU continues the interrupted program again. However, the program is now corrupt since it relies on the original <code>mm1</code> value.</p>

<h3 id="saving-and-restoring-multimedia-registers">Saving and Restoring Multimedia Registers</h3>

<p>In order to fix this problem, we need to backup all caller-saved multimedia registers before we call the exception handler. The problem is that the set of multimedia registers varies between CPUs. There are different standards:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/MMX_(instruction_set)">MMX</a>: The MMX instruction set was introduced in 1997 and defines eight 64 bit registers called <code>mm0</code> through <code>mm7</code>. These registers are just aliases for the registers of the <a href="https://en.wikipedia.org/wiki/X87">x87 floating point unit</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a>: The <em>Streaming SIMD Extensions</em> instruction set was introduced in 1999. Instead of re-using the floating point registers, it adds a completely new register set. The sixteen new registers are called <code>xmm0</code> through <code>xmm15</code> and are 128 bits each.</li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>: The <em>Advanced Vector Extensions</em> are extensions that further increase the size of the multimedia registers. The new registers are called <code>ymm0</code> through <code>ymm15</code> and are 256 bits each. They extend the <code>xmm</code> registers, so e.g. <code>xmm0</code> is the lower (or upper?) half of <code>ymm0</code>.</li>
</ul>

<p>The Rust compiler (and LLVM) assume that the <code>x86_64-unknown-linux-gnu</code> target supports only MMX and SSE, so we don&rsquo;t need to save the <code>ymm0</code> through <code>ymm15</code>. But we need to save <code>xmm0</code> through <code>xmm15</code> and also <code>mm0</code> through <code>mm7</code>. There is a special instruction to do this: <a href="http://x86.renejeschke.de/html/file_module_x86_id_128.html">fxsave</a>. This instruction saves the floating point and multimedia state to a given address. It needs <em>512 bytes</em> to store that state.</p>

<p>In order to save/restore the multimedia registers, we <em>could</em> add new macros:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">save_multimedia_registers</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;sub rsp, 512</span>
<span class="s">              fxsave [rsp]</span>
<span class="s">        &quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">restore_multimedia_registers</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;fxrstor [rsp]</span>
<span class="s">              add rsp, 512</span>
<span class="s">            &quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>First, we reserve the 512 bytes on the stack and then we use <code>fxsave</code> to backup the multimedia registers. In order to restore them later, we use the <a href="http://x86.renejeschke.de/html/file_module_x86_id_127.html">fxrstor</a> instruction. Note that <code>fxsave</code> and <code>fxrstor</code> require a 16 byte aligned memory address.</p>

<p>However, <em>we won&rsquo;t do it that way</em>. The problem is the large amount of memory required. We will reuse the same code when we handle hardware interrupts in a future post. So for each mouse click, pressed key, or arrived network package we need to write 512 bytes to memory. This would be a huge performance problem.</p>

<p>Fortunately, there exists an alternative solution.</p>

<h3 id="disabling-multimedia-extensions">Disabling Multimedia Extensions</h3>

<p>We just disable MMX, SSE, and all the other fancy multimedia extensions in our kernel<sup class="footnote-ref" id="fnref:fn-userspace-sse"><a rel="footnote" href="#fn:fn-userspace-sse">1</a></sup>. This way, our exception handlers won&rsquo;t clobber the multimedia registers because they won&rsquo;t use them at all.</p>

<p>This solution has its own disadvantages, of course. For example, it leads to slower kernel code because the compiler can&rsquo;t perform any auto-vectorization optimizations. But it&rsquo;s still the faster solution (since we save many memory accesses) and most kernels do it this way (including Linux).</p>

<p>So how do we disable MMX and SSE? Well, we just tell the compiler that our target system doesn&rsquo;t support it. Since the very beginning, we&rsquo;re compiling our kernel for the <code>x86_64-unknown-linux-gnu</code> target. This worked fine so far, but now we want a different target without support for multimedia extensions. We can do so by creating a <em>target configuration file</em>.</p>

<h3 id="target-specifications">Target Specifications</h3>

<p>In order to disable the multimedia extensions for our kernel, we need to compile for a custom target. We want a target that is equal to <code>x86_64-unknown-linux-gnu</code>, but without MMX and SSE support. Rust allows us to specify such a target using a JSON configuration file.</p>

<p>A minimal target specification that describes the <code>x86_64-unknown-linux-gnu</code> target looks like this:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;llvm-target&quot;</span><span class="p">:</span> <span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span><span class="p">,</span>
  <span class="nt">&quot;data-layout&quot;</span><span class="p">:</span> <span class="s2">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><span class="p">,</span>
  <span class="nt">&quot;target-endian&quot;</span><span class="p">:</span> <span class="s2">&quot;little&quot;</span><span class="p">,</span>
  <span class="nt">&quot;target-pointer-width&quot;</span><span class="p">:</span> <span class="s2">&quot;64&quot;</span><span class="p">,</span>
  <span class="nt">&quot;arch&quot;</span><span class="p">:</span> <span class="s2">&quot;x86_64&quot;</span><span class="p">,</span>
  <span class="nt">&quot;os&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span>
<span class="p">}</span>
</code></pre></div>

<p>The <code>llvm-target</code> field specifies the target triple that is passed to LLVM. We want to derive a 64-bit Linux target, so we choose <code>x86_64-unknown-linux-gnu</code>. The <code>data-layout</code> field is also passed to LLVM and specifies how data should be laid out in memory. It consists of various specifications seperated by a <code>-</code> character. For example, the <code>e</code> means little endian and <code>S128</code> specifies that the stack should be 128 bits (= 16 byte) aligned. The format is described in detail in the <a href="http://llvm.org/docs/LangRef.html#data-layout">LLVM documentation</a> but there shouldn&rsquo;t be a reason to change this string.</p>

<p>The other fields are used for conditional compilation. This allows crate authors to use <code>cfg</code> variables to write special code for depending on the OS or the architecture. There isn&rsquo;t any up-to-date documentation about these fields but the <a href="https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src/librustc_back/target/mod.rs#L194-L214">corresponding source code</a> is quite readable.</p>

<h4 id="disabling-mmx-and-sse">Disabling MMX and SSE</h4>

<p>In order to disable the multimedia extensions, we create a new target named <code>x86_64-blog_os</code>. To describe this target, we create a file named <code>x86_64-blog_os.json</code> in the project root with the following content:</p>

<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;llvm-target&quot;</span><span class="p">:</span> <span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span><span class="p">,</span>
  <span class="nt">&quot;data-layout&quot;</span><span class="p">:</span> <span class="s2">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><span class="p">,</span>
  <span class="nt">&quot;target-endian&quot;</span><span class="p">:</span> <span class="s2">&quot;little&quot;</span><span class="p">,</span>
  <span class="nt">&quot;target-pointer-width&quot;</span><span class="p">:</span> <span class="s2">&quot;64&quot;</span><span class="p">,</span>
  <span class="nt">&quot;arch&quot;</span><span class="p">:</span> <span class="s2">&quot;x86_64&quot;</span><span class="p">,</span>
  <span class="nt">&quot;os&quot;</span><span class="p">:</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
<span class="hll">  <span class="nt">&quot;features&quot;</span><span class="p">:</span> <span class="s2">&quot;-mmx,-sse&quot;</span>
</span><span class="p">}</span>
</code></pre></div>


<p>It&rsquo;s equal to <code>x86_64-unknown-linux-gnu</code> target but has one additional option: <code>&quot;features&quot;: &quot;-mmx,-sse&quot;</code>. So we added two target <em>features</em>: <code>-mmx</code> and <code>-sse</code>. The minus prefix defines that our target does <em>not</em> support this feature. So by specifying <code>-mmx</code> and <code>-sse</code>, we disable the default <code>mmx</code> and <code>sse</code> features.</p>

<p>In order to compile for the new target, we need to adjust our Makefile:</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"><span></span># in `Makefile`

 arch ?= x86_64
<span class="gd">-target ?= $(arch)-unknown-linux-gnu</span>
<span class="gi">+target ?= $(arch)-blog_os</span>
...
</code></pre></div>

<p>The new target name (<code>x86_64-blog_os</code>) is the file name of the JSON configuration file without the <code>.json</code> extension.</p>

<h3 id="cross-compilation">Cross compilation</h3>

<p>Let&rsquo;s try if our kernel still works with the new target:</p>

<pre><code>&gt; make run
Compiling raw-cpuid v2.0.1
Compiling rlibc v0.1.5
Compiling x86 v0.7.1
Compiling spin v0.3.5
error[E0463]: can't find crate for `core`

error: aborting due to previous error

Build failed, waiting for other jobs to finish...
...
Makefile:52: recipe for target 'cargo' failed
make: *** [cargo] Error 101
</code></pre>

<p>It doesn&rsquo;t compile anymore. The error tells us that the Rust compiler no longer finds the core library.</p>

<p>The <a href="https://doc.rust-lang.org/nightly/core/index.html">core library</a> is implicitly linked to all <code>no_std</code> crates and contains things such as <code>Result</code>, <code>Option</code>, and iterators. We&rsquo;ve used that library without problems since <a href="/set-up-rust.html">the very beginning</a>, so why is it no longer available?</p>

<p>The problem is that the core library is distributed together with the Rust compiler as a <em>precompiled</em> library. So it is only valid for the host triple, which is <code>x86_64-unknown-linux-gnu</code> in our case. If we want to compile code for other targets, we need to recompile <code>core</code> for these targets first.</p>

<h4 id="xargo">Xargo</h4>

<p>That&rsquo;s where <a href="https://github.com/japaric/xargo">xargo</a> comes in. It is a wrapper for cargo that eases cross compilation. We can install it by executing:</p>

<pre><code>cargo install xargo
</code></pre>

<p>Xargo depends on the rust source code, which we can install with <code>rustup component add rust-src</code>.</p>

<p>Xargo is “a drop-in replacement for cargo”, so every cargo command also works with <code>xargo</code>. You can do e.g. <code>xargo --help</code>, <code>xargo clean</code>, or <code>xargo doc</code>. However, the <code>build</code> command gains additional functionality: <code>xargo build</code> will automatically cross compile the <code>core</code> library when compiling for custom targets.</p>

<p>That&rsquo;s exactly what we want, so we change one letter in our Makefile:</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"><span></span># in `Makefile`
...

cargo:
<span class="gd">-	@cargo build --target $(target)</span>
<span class="gi">+	@xargo build --target $(target)</span>
...
</code></pre></div>

<p>Now the build goes through <code>xargo</code>, which should fix the compilation error. Let&rsquo;s try it out:</p>

<pre><code>&gt; make run
Compiling core v0.0.0 (file:///home/…/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore)
LLVM ERROR: SSE register return with SSE disabled
error: Could not compile `core`.
</code></pre>

<p>Well, we get a different error now, so it seems like we&rsquo;re making progress :). It seems like there is a “SSE register return” although SSE is disabled. But what&rsquo;s an “SSE register return”?</p>

<h3 id="sse-register-return">SSE Register Return</h3>

<p>Remember when we discussed calling conventions above? The calling convention defines which registers are used for return values. Well, the <a href="http://refspecs.linuxbase.org/elf/x86-64-abi-0.99.pdf">System V ABI</a> defines that <code>xmm0</code> should be used for returning floating point values. So somewhere in the <code>core</code> library a function returns a float and LLVM doesn&rsquo;t know what to do. The ABI says “use <code>xmm0</code>” but the target specification says “don&rsquo;t use <code>xmm</code> registers”.</p>

<p>In order to fix this problem, we need to change our float ABI. The idea is to avoid normal hardware-supported floats and use a pure software implementation instead. We can do so by enabling the <code>soft-float</code> feature for our target. For that, we edit <code>x86_64-blog_os.json</code>:</p>

<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;llvm-target&quot;</span><span class="p">:</span> <span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span><span class="p">,</span>
  <span class="err">...</span>
<span class="hll">  <span class="nt">&quot;features&quot;</span><span class="p">:</span> <span class="s2">&quot;-mmx,-sse,+soft-float&quot;</span>
</span><span class="p">}</span>
</code></pre></div>


<p>The plus prefix tells LLVM to enable the <code>soft-float</code> feature.</p>

<p>Let&rsquo;s try <code>make run</code> again:</p>

<pre><code>&gt; make run
   Compiling core v0.0.0 (file:///…/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore)
    Finished release [optimized] target(s) in 21.95 secs
   Compiling spin v0.4.5
   Compiling once v0.3.2
   Compiling x86 v0.8.0
   Compiling bitflags v0.7.0
   Compiling raw-cpuid v2.0.1
   Compiling rlibc v0.1.5
   Compiling linked_list_allocator v0.2.3
   Compiling volatile v0.1.0
   Compiling bitflags v0.4.0
   Compiling bit_field v0.5.0
   Compiling spin v0.3.5
   Compiling multiboot2 v0.1.0
   Compiling lazy_static v0.2.2
   Compiling hole_list_allocator v0.1.0 (file:///…/libs/hole_list_allocator)
   Compiling blog_os v0.1.0 (file:///…)
error[E0463]: can't find crate for `alloc`
  --&gt; src/lib.rs:33:1
   |
33 | extern crate alloc;
   | ^^^^^^^^^^^^^^^^^^^ can't find crate

error: aborting due to previous error
</code></pre>

<p>We see that <code>xargo</code> now compiles the <code>core</code> crate in release mode. Then it starts the normal cargo build. Cargo then recompiles all dependencies, since it needs to generate different code for the new target.</p>

<p>However, the build still fails. The reason is that xargo only installs <code>core</code> by default, but we also need the <code>alloc</code> and <code>collections</code> crates. We can enable them by creating a file named <code>Xargo.toml</code> with the following contents:</p>
<div class="highlight"><pre><code class="language-toml" data-lang="toml"><span></span><span class="c1"># Xargo.toml</span>

<span class="p">[</span><span class="n">target</span><span class="p">.</span><span class="n">x86_64-blog_os</span><span class="p">.</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">collections</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div>

<p>Now xargo compiles <code>alloc</code> and <code>collections</code>, too:</p>

<pre><code>&gt; make run
   Compiling core v0.0.0 (file:///…/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore)
   Compiling std_unicode v0.0.0 (file:///…/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd_unicode)
   Compiling alloc v0.0.0 (file:///…/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/liballoc)
   Compiling collections v0.0.0 (file:///…/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcollections)
    Finished release [optimized] target(s) in 28.84 secs
   Compiling blog_os v0.1.0 (file:///…/Documents/blog_os/master)
warning: unused variable: `allocator` […]
warning: unused variable: `frame` […]

    Finished debug [unoptimized + debuginfo] target(s) in 1.75 secs
</code></pre>

<p>It worked! Now we have a kernel that never touches the multimedia registers! We can verify this by executing:</p>

<pre><code>&gt; objdump -d build/kernel-x86_64.bin | grep &quot;mm[0-9]&quot;
</code></pre>

<p>If the command produces no output, our kernel uses neither MMX (<code>mm0</code> – <code>mm7</code>) nor SSE (<code>xmm0</code> – <code>xmm15</code>) registers.</p>

<p>So now our return-from-exception logic works without problems in <em>most</em> cases. However, there is still a pitfall hidden in the C calling convention, which might cause hideous bugs in some rare cases.</p>

<h2 id="the-red-zone">The Red Zone</h2>

<p>The <a href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64#the-red-zone">red zone</a> is an optimization of the <a href="http://refspecs.linuxbase.org/elf/x86-64-abi-0.99.pdf">System V ABI</a> that allows functions to temporary use the 128 bytes below its stack frame without adjusting the stack pointer:</p>

<p><img src="images/red-zone.svg" alt="stack frame with red zone" /></p>

<p>The image shows the stack frame of a function with <code>n</code> local variables. On function entry, the stack pointer is adjusted to make room on the stack for the local variables.</p>

<p>The red zone is defined as the 128 bytes below the adjusted stack pointer. The function can use this area for temporary data that&rsquo;s not needed across function calls. Thus, the two instructions for adjusting the stack pointer can be avoided in some cases (e.g. in small leaf functions).</p>

<p>However, this optimization leads to huge problems with exceptions. Let&rsquo;s assume that an exception occurs while a function uses the red zone:</p>

<p><img src="images/red-zone-overwrite.svg" alt="red zone overwritten by exception handler" /></p>

<p>The CPU and the exception handler overwrite the data in red zone. But this data is still needed by the interrupted function. So the function won&rsquo;t work correctly anymore when we return from the exception handler. It might fail or cause another exception, but it could also lead to strange bugs that <a href="http://forum.osdev.org/viewtopic.php?t=21720">take weeks to debug</a>.</p>

<h3 id="adjusting-our-exception-handler">Adjusting our Exception Handler?</h3>

<p>The problem is that the <a href="http://refspecs.linuxbase.org/elf/x86-64-abi-0.99.pdf">System V ABI</a> demands that the red zone <em>“shall not be modified by signal or interrupt handlers.”</em> Our current exception handlers do not respect this. We could try to fix it by subtracting 128 from the stack pointer before pushing anything:</p>
<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span></span><span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">128</span>
<span class="nf">save_scratch_registers</span><span class="p">()</span>
<span class="nf">...</span>
<span class="nf">call</span> <span class="nv">...</span>
<span class="nf">...</span>
<span class="kd">rest</span><span class="nv">ore_scratch_registers</span><span class="p">()</span>
<span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">128</span>

<span class="nf">iretq</span>
</code></pre></div>

<p><em>This will not work.</em> The problem is that the CPU pushes the exception stack frame before even calling our handler function. So the CPU itself will clobber the red zone and there is nothing we can do about that. So our only chance is to disable the red zone.</p>

<h3 id="disabling-the-red-zone">Disabling the Red Zone</h3>

<p>The red zone is a property of our target, so in order to disable it we edit our <code>x86_64-blog_os.json</code> a last time:</p>

<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;llvm-target&quot;</span><span class="p">:</span> <span class="s2">&quot;x86_64-unknown-linux-gnu&quot;</span><span class="p">,</span>
  <span class="err">...</span>
  <span class="nt">&quot;features&quot;</span><span class="p">:</span> <span class="s2">&quot;-mmx,-sse,+soft-float&quot;</span><span class="p">,</span>
<span class="hll">  <span class="nt">&quot;disable-redzone&quot;</span><span class="p">:</span> <span class="kc">true</span>
</span><span class="p">}</span>
</code></pre></div>


<p>We add one additional option at the end: <code>&quot;disable-redzone&quot;: true</code>. As you might guess, this option disables the red zone optimization.</p>

<p>Now we have a red zone free kernel!</p>

<h2 id="exceptions-with-error-codes">Exceptions with Error Codes</h2>

<p>We&rsquo;re now able to correctly return from exceptions without error codes. However, we still can&rsquo;t return from exceptions that push an error code (e.g. page faults). Let&rsquo;s fix that by updating our <code>handler_with_error_code</code> macro:</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">handler_with_error_code</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$name</span><span class="o">:</span><span class="w"> </span><span class="n">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[naked]</span><span class="w"></span>
<span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">wrapper</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;pop rsi // pop error code into rsi</span>
<span class="s">                      mov rdi, rsp</span>
<span class="s">                      sub rsp, 8 // align the stack pointer</span>
<span class="s">                      call $0&quot;</span><span class="w"></span>
<span class="w">                      </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="cp">$name</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="w"></span>
<span class="hll"><span class="w">                          </span><span class="o">&amp;</span><span class="n">ExceptionStackFrame</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">))</span><span class="w"></span>
</span><span class="w">                      </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;rdi&quot;</span><span class="p">,</span><span class="s">&quot;rsi&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">);</span><span class="w"></span>
<span class="hll"><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;iretq&quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
</span><span class="w">                </span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">intrinsics</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">wrapper</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<!--end*--></p>

<p>First, we change the type of the handler function: no more <code>-&gt; !</code>, so it no longer needs to diverge. We also add an <code>iretq</code> instruction at the end.</p>

<p>Now we can make our <code>page_fault_handler</code> non-diverging:</p>
<div class="highlight"><pre><code class="language-diff" data-lang="diff"><span></span>// in src/interrupts/mod.rs

 extern &quot;C&quot; fn page_fault_handler(stack_frame: &amp;ExceptionStackFrame,
<span class="gd">-   error_code: u64) -&gt; ! { ... }</span>
<span class="gi">+   error_code: u64) { ... }</span>
</code></pre></div>

<p>However, now we have the same problem as above: The handler function will overwrite the scratch registers and cause bugs when returning. Let&rsquo;s fix this by invoking <code>save_scratch_registers</code> at the beginning:</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">handler_with_error_code</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$name</span><span class="o">:</span><span class="w"> </span><span class="n">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[naked]</span><span class="w"></span>
<span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">wrapper</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="hll"><span class="w">                </span><span class="n">save_scratch_registers</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
</span><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;pop rsi // pop error code into rsi</span>
<span class="s">                      mov rdi, rsp</span>
<span class="hll"><span class="s">                      add rdi, 10*8 // calculate exception stack frame pointer</span>
</span><span class="s">                      sub rsp, 8 // align the stack pointer</span>
<span class="s">                      call $0</span>
<span class="hll"><span class="s">                      add rsp, 8 // undo stack pointer alignment</span>
</span><span class="s">                      &quot;</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="cp">$name</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="w"></span>
<span class="w">                          </span><span class="o">&amp;</span><span class="n">ExceptionStackFrame</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">))</span><span class="w"></span>
<span class="w">                      </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;rdi&quot;</span><span class="p">,</span><span class="s">&quot;rsi&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">);</span><span class="w"></span>
<span class="hll"><span class="w">                </span><span class="n">restore_scratch_registers</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
</span><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;iretq&quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">intrinsics</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">wrapper</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<!--end*-->
Now we backup the scratch registers to the stack right at the beginning and restore them just before the <code>iretq</code>. Like in the <code>handler</code> macro, we now need to add <code>10*8</code> to <code>rdi</code> in order to get the correct exception stack frame pointer (<code>save_scratch_registers</code> pushes nine 8 byte registers, plus the error code). We also need to undo the stack pointer alignment after the <code>call</code> <sup class="footnote-ref" id="fnref:fn-stack-alignment"><a rel="footnote" href="#fn:fn-stack-alignment">2</a></sup>.</p>

<p>Now we have one last bug: We <code>pop</code> the error code into <code>rsi</code>, but the error code is no longer at the top of the stack (since <code>save_scratch_registers</code> pushed 9 registers on top of it). So we need to do it differently:</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/interrupts/mod.rs</span>

<span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">handler_with_error_code</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="cp">$name</span><span class="o">:</span><span class="w"> </span><span class="n">ident</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{{</span><span class="w"></span>
<span class="w">        </span><span class="cp">#[naked]</span><span class="w"></span>
<span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">wrapper</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">save_scratch_registers</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
<span class="hll"><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;mov rsi, [rsp + 9*8] // load error code into rsi</span>
</span><span class="s">                      mov rdi, rsp</span>
<span class="s">                      add rdi, 10*8 // calculate exception stack frame pointer</span>
<span class="s">                      sub rsp, 8 // align the stack pointer</span>
<span class="s">                      call $0</span>
<span class="s">                      add rsp, 8 // undo stack pointer alignment</span>
<span class="s">                      &quot;</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;i&quot;</span><span class="p">(</span><span class="cp">$name</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span><span class="p">(</span><span class="w"></span>
<span class="w">                          </span><span class="o">&amp;</span><span class="n">ExceptionStackFrame</span><span class="p">,</span><span class="w"> </span><span class="kt">u64</span><span class="p">))</span><span class="w"></span>
<span class="w">                      </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;rdi&quot;</span><span class="p">,</span><span class="s">&quot;rsi&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">restore_scratch_registers</span><span class="o">!</span><span class="p">();</span><span class="w"></span>
<span class="hll"><span class="w">                </span><span class="n">asm</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;add rsp, 8 // pop error code</span>
</span><span class="s">                      iretq&quot;</span><span class="w"> </span><span class="o">::::</span><span class="w"> </span><span class="s">&quot;intel&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;volatile&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">intrinsics</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">wrapper</span><span class="w"></span>
<span class="w">    </span><span class="p">}}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<!--end*--></p>

<p>Instead of using <code>pop</code>, we&rsquo;re calculating the error code address manually (<code>save_scratch_registers</code> pushes nine 8 byte registers) and load it into <code>rsi</code> using a <code>mov</code>. So now the error code stays on the stack. But <code>iretq</code> doesn&rsquo;t handle the error code, so we need to pop it before invoking <code>iretq</code>.</p>

<p>Phew! That was a lot of fiddling with assembly. Let&rsquo;s test if it still works.</p>

<h3 id="testing-1">Testing</h3>

<p>First, we test if the exception stack frame pointer and the error code are still correct:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in rust_main in src/lib.rs</span>

<span class="p">...</span><span class="w"></span>
<span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">int</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// provoke a page fault</span>
<span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="mh">0xdeadbeaf</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;It did not crash!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">loop</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>

<p>This should cause the following error message:</p>

<pre><code>EXCEPTION: PAGE FAULT while accessing 0xdeadbeaf
error code: CAUSED_BY_WRITE
ExceptionStackFrame {
    instruction_pointer: 1114753,
    code_segment: 8,
    cpu_flags: 2097158,
    stack_pointer: 1171104,
    stack_segment: 16
}
</code></pre>

<p>The error code should still be <code>CAUSED_BY_WRITE</code> and the exception stack frame values should also be correct (e.g. <code>code_segment</code> should be 8 and <code>stack_segment</code> should be 16).</p>

<h4 id="returning-from-page-faults">Returning from Page Faults</h4>

<p>Let&rsquo;s see what happens if we comment out the trailing <code>loop</code> in our page fault handler:</p>

<p><img src="images/qemu-page-fault-return.png" alt="QEMU printing the same page fault message again and again" /></p>

<p>We see that the same error message is printed over and over again. Here is what happens:</p>

<ul>
<li>The CPU executes <code>rust_main</code> and tries to access <code>0xdeadbeaf</code>. This causes a page fault.</li>
<li>The page fault handler prints an error message and returns without fixing the cause of the exception (<code>0xdeadbeaf</code> is still unaccessible).</li>
<li>The CPU restarts the instruction that caused the page fault and thus tries to access <code>0xdeadbeaf</code> again. Of course, this causes a page fault again.</li>
<li>The page fault handler prints the error message and returns.</li>
</ul>

<p>… and so on. Thus, our code indefinitely jumps between the page fault handler and the instruction that accesses <code>0xdeadbeaf</code>.</p>

<p>This is a good thing! It means that our <code>iretq</code> logic is working correctly, since it returns to the correct instruction every time. So our <code>handler_with_error_code</code> macro seems to be correct.</p>

<h2 id="what-s-next">What&rsquo;s next?</h2>

<p>We are now able to catch exceptions and to return from them. However, there are still exceptions that completely crash our kernel by causing a <a href="https://en.wikipedia.org/wiki/Triple_fault">triple fault</a>. In the next post, we will fix this issue by handling a special type of exception: the <a href="https://en.wikipedia.org/wiki/Double_fault">double fault</a>. Thus, we will be able to avoid random reboots in our kernel.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:fn-userspace-sse">Userspace programs will still be able to use the multimedia registers.
 <a class="footnote-return" href="#fnref:fn-userspace-sse"><sup>[return]</sup></a></li>
<li id="fn:fn-stack-alignment">The stack alignment is actually wrong here, since we additionally pushed an uneven number of registers. However, the <code>pop rsi</code> is wrong too, since the error code is no longer at the top of the stack. When we fix that problem, the stack alignment becomes correct again. So I left it in to keep things simple.
 <a class="footnote-return" href="#fnref:fn-stack-alignment"><sup>[return]</sup></a></li>
</ol>
</div>

</article>

<hr>
<div class="PageNavigation">
  
    <a class="prev" href="/better-exception-messages.html">&laquo; Better Exception Messages</a>
  
  
    <a class="next" href="/double-faults.html">Double Faults &raquo;</a>
  
</div>
<hr>

<div id="disqus_thread"></div>
<script>
  (function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var d = document, s = d.createElement('script');

    s.src = '//phil-opp.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<script type="text/javascript">
  anchors.options = {
    placement: 'left',
  };
  anchors.add('article h2, article h3, article h4, article h5, article h6');
</script>

</main>

<footer class="footer">
  <small>
    &copy;
    <time datetime="2017">2017</time>. All rights reserved.
    <a href="/contact.html">Contact</a>
  </small>
</footer>
</div>

</body>
</html>

